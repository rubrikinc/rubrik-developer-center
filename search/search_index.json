{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":""},{"location":"#why-apis-are-important","title":"Why APIs are Important","text":"<p>Automation, Integration, and Observability are all key requirements for any modern IT system. Rubrik was founded on the principle of delivering an API-first architecture, to be a perfect fit for your organization's data security and resiliency strategy.</p>"},{"location":"#rubriks-apis","title":"Rubrik's APIs","text":"<p>Rubrik has two APIs for consumption.</p>"},{"location":"#rubrik-security-cloudrsc-api","title":"Rubrik Security Cloud(RSC) API","text":"<p>The Rubrik Security Cloud API is based on GraphQL. The reason we chose GraphQL was two-fold. </p> <ol> <li>Introspection - API documentation is built in to the API itself. This means you can \"ask\" the API about itself, and there is no separate process for building documentation. The schema is the documentation. Along with built-in documentation, GraphQL is strongly-typed, which means you don't have to guess the format of the arguments to an API call. Understanding object structure is a common issue with REST.</li> <li>Performance - Rubrik has a LOT of metadata available to you. Generally you'll find that REST APIs give you every property back from an object, whether you needed it or not. This can cause performance issues and much higher complexity at scale. GraphQL allows you to select just the properties you need. This makes a big difference when we're talking about retrieving information about thousands of protected objects.</li> </ol>"},{"location":"#rubrik-cluster-api","title":"Rubrik Cluster API","text":"<p>The Rubrik Cluster API is REST based, and is located on each physical or virtual (Cloud Cluster). The primary purposes for this API are:</p> <ol> <li>Offline Recovery - In the event that you've gone dark and are unable to access the Internet, You're still able to automate your disaster recovery plan.</li> <li>Air-gapped Automation - Some systems performing backup automation may not have access to the Internet. A common example is a database server that initiates backups at a very specific time. The database server cloud have a script to freeze and write its logs, and needs to tell Rubrik to initiate the backup.</li> </ol>"},{"location":"#help-im-new-to-graphql","title":"Help! I'm new to GraphQL!","text":"<p>It can be uncomfortable learning a new technology, but GraphQL is has reached maturity and there are a number of large organizations adopting it. </p> <p>When learning any new language, I work first to understand what it actually does differently. Since it is a \"query language,\" I like to compare it to SQL. In SQL, we might say, \"Select name and ID from the VM table.\" GraphQL is similar in this idea. We run a named query which is much like a SQL table. We then select the properties called fields, which are like columns in that table. Now, I won't get too complex at this point, but some of those properties are objects that may have their own properties.</p> <p>Here's an example. Click on the arrow annotation (1) in the code to see an explanation of that part of the code.</p> <ol> <li>This is an annotation!</li> </ol> <p>Retrieve all MSSQL databases, and give me the name, ID, and the name and ID of the Rubrik Cluster that protect's this MSSQL database.</p> <pre><code>query mssqlDatabasesExample { #(1)!\n{ .annotate }\n  mssqlDatabases { # (2)!\n    nodes  { #(3)!\n      name #(4)! \n      id\n      cluster { #(5)!\n        name #(6)!\n        id\n      }\n    }\n  }\n}\n</code></pre> <ol> <li><code>mssqlDatabasesExample</code> is an operation name, You can change this to whatever you want.</li> <li><code>mssqlDatabases</code> is the name of the query in the API.</li> <li><code>nodes</code> is a paginated array of objects, in this case, mssqlDatabases.</li> <li><code>name</code> is a property, known as a <code>field</code> in GraphQL. It has a specific type, in this case <code>name</code> is a <code>String</code>.</li> <li><code>cluster</code> is also a field in the API, but unlike <code>name</code> that is of type <code>String</code>, <code>cluster</code> is a <code>Cluster</code> type, and it has its own fields.</li> <li>This is the cluster <code>name</code> field. It's a field on the <code>Cluster</code> type in the API.</li> </ol> <p>If you want to learn more about the query syntax, check out GraphQL Language Syntax. </p> <p>Ready to move on? If so, let's head to API Playground</p>"},{"location":"API-playground/","title":"API playground","text":"<p>The API Playground is an integrated development environment (IDE) that you can use to browse, explore, and run GraphQL APIs offered by Rubrik Security Cloud (RSC). The IDE also provides reference to the Rubrik GraphQL API documentation for your version. Running GraphQL queries and mutations in API Playground validates the GraphQL operations so that you can confirm that your queries or mutations will achieve the desired result when included in automation scripts.</p> <p>After logging in to API Playground with your RSC user account credentials, you can choose to run GraphQL queries and mutations either as yourself or with a service account. The level of access you have for running the GraphQL queries and mutations depends on the RBAC roles assigned to your user account or to the service account you are using. For enhanced security, API Playground does not persist the service account access credentials.</p> <p>Danger</p> <p>The GraphQL mutations that you run in API Playground perform actions against your production environment. This can result in data loss.</p>"},{"location":"API-playground/#accessing-api-playground","title":"Accessing API Playground","text":"<p>You can access API Playground through the RSC Settings menu or directly through the url bar in your browser.</p> <ol> <li>Log in to RSC.</li> <li>Open the app tray and select Settings. The Settings menu appears.</li> <li>Click API Playground. The API Playground page appears.</li> <li>Click Open API Playground. API Playground opens in a new browser tab.</li> </ol> <p>Alternatively, you can open the playground directly by supplying the url in this format:</p> <pre><code>https://&lt;INSTANCE&gt;.my.rubrik.com/playground/\n</code></pre> <p>Now that you have access to the playground, let's try it out by getting a list of SLA Domains. Copy and paste the below query into the code pane of the playground, then click the \"execute query\" button.</p> <pre><code>{\n  slaDomains {\n    nodes {\n      name\n      id\n    }\n  }\n}\n</code></pre> <p>You should have received some output that looked something like this...</p> <pre><code>{\n  \"data\": {\n    \"slaDomains\": {\n      \"nodes\": [\n        {\n          \"name\": \"Bronze\",\n          \"id\": \"00000000-0000-0000-0000-000000000002\"\n        },\n        {\n          \"name\": \"Gold\",\n          \"id\": \"00000000-0000-0000-0000-000000000000\"\n        },\n        {\n          \"name\": \"Silver\",\n          \"id\": \"00000000-0000-0000-0000-000000000001\"\n        }\n      ]\n    }\n  }\n}\n</code></pre> <p>If so, Congrats! Let's add a bit more to our query. I want to find an SLA Domain by name. Let's use the built-in API documentation to find out how to do that.</p> <ol> <li>Hover your mouse cursor over <code>slaDomains</code> in your query.</li> <li>Click on the <code>slaDomains</code> link when the tooltip appears.</li> </ol> <p>A side pane will appear with the API documentation for <code>slaDomains.</code></p> <p>You'll notice two sections: <code>Type</code> and <code>Arguments</code></p> <ul> <li><code>Type</code> - This is the type of object that gets returned.</li> <li><code>Arguments</code> - These are what we can pass into the query, such as name filters.</li> </ul> <p>You'll notice that the arguments have types specified next to the name. Let's take a look at the <code>filter</code> argument. It as a type of <code>[GlobalSlaFilterInput!]</code></p> <ul> <li><code>[]</code> The square braces indicate that we can pass in multiple<code>GlobalSlaFilterInput</code> objects. This is good if we want to filterby name and something else.</li> <li><code>!</code> The exclamation point means \"Non-Null.\" You'll see thisindicated both in arguments and fields that get returnedindicating that it's a contractual obligation for that type ofobject to be provided.</li> </ul> <p>Click on the <code>GlobalSlaFilterInput</code> type in the documentation. The documentation will direct you to the documentation for this type.</p> <p>We're interested in filtering by name, but there's no name? Name is actually a searchable <code>field</code> we'll need to specify. If you click on <code>GlobalSlaQueryFilterInputField</code>, there are several fields to choose from.</p> <p>Ultimately, you will supply the <code>field</code> and <code>text</code>. <code>field</code> will be <code>NAME</code> and text will be the SLA domain name we want to search for.</p> <p>Note</p> <p>Some queries will have their own filtering arguments that are unique to the context of that object. Be sure to lean on the API documentation for help!</p> <p>We provide arguments to a query in parenthesis <code>()</code> after the query name. Let's create our filter object as an argument to our previous query. You can change the <code>text</code> content to an SLA domain name in your environment, although you should have a \"bronze\" SLA by default.</p> <pre><code>{\n  slaDomains(filter: {field: NAME text: \"bronze\"}) {\n    nodes {\n      name\n      id\n    }\n  }\n}\n</code></pre> <p>Our result will be only SLA Domains starting with <code>bronze</code> (or whatever you picked) in the name!</p> <pre><code>{\n  \"data\": {\n    \"slaDomains\": {\n      \"nodes\": [\n        {\n          \"name\": \"Bronze\",\n          \"id\": \"00000000-0000-0000-0000-000000000002\"\n        }\n      ]\n    }\n  }\n}\n</code></pre> <p>Next, let's talk about running GraphQL calls outside of the playground, starting with authentication!</p>"},{"location":"authentication/","title":"Authentication","text":""},{"location":"authentication/#service-accounts","title":"Service Accounts","text":"<p>A service account represents an application that needs authentication and authorization to invoke Rubrik APIs, as opposed to a user account that represents an individual user. Service accounts use a client secret to authenticate to an authorization server and obtain an access token to invoke the Rubrik APIs. Similar to user accounts, Rubrik allows assigning roles to the service accounts to enable role-based access control. But contrary to user accounts, service accounts cannot be used to access the Rubrik web UI.</p>"},{"location":"authentication/#security","title":"Security","text":"<p>Service accounts enable client applications and other services to invoke the Rubrik APIs securely. When creating a service account, the authorization server assigns a unique client ID and client secret to the account. The combination of client ID and client secret is known as client credentials. The client credentials are known only to the client that is represented by the service account and the authorization server that grants the credentials to the service account. The client application authenticates to the authorization server using the client credentials and obtains an access token to authenticate to the Rubrik API server and access the protected resources.</p>"},{"location":"authentication/#guidelines","title":"Guidelines","text":"<p>Consider the following best practices when using service accounts:</p> <ul> <li>One service account should represent only one client application.</li> <li>The role assigned to the service account should be the one with least number of privileges that would be sufficient for the client application being represented by the service account to access the Rubrik APIs.</li> <li>The client credentials must be saved when they are first created as Rubrik does not provide an option to display them again.</li> <li>The client secret must be treated like a password and stored in a secure location.</li> <li>Service account access tokens should be cached and reused until they are valid.</li> </ul>"},{"location":"authentication/#usage","title":"Usage","text":""},{"location":"authentication/#adding-a-service-account","title":"Adding a service account","text":"<p>Refer to the RSC userguide: adding a service account</p>"},{"location":"authentication/#obtaining-an-access-token","title":"Obtaining an access token","text":"<p>In a terminal window, run the following command: <pre><code>curl --request POST --header \"Content-Type: application/json\" \\\n--data '{\"client_id\": \"$client_id\", \"client_secret\": \"$client_secret\"}' \\\n$access_token_uri\n</code></pre></p> <p>For example, the following command uses sample values for the variables: <pre><code>curl --request POST --header \"Content-Type: application/json\" \\\n--data '{\"client_id\": \"client|EKy4bNDSGJfXbJZsJS2dQ5fiaeEoj1zu\", \"client_secret\": \"iNGp5X14xvD16XKwiiEqEAMAF6RxOucQIhTv9DjVC5U7BorvS5LZSEPFBhjQvo2\"}' \\\nhttps://$account.my.rubrik.com/api/client_token\n</code></pre></p> <p>The authorization server responds with an encoded access token. Client applications use the access token to invoke Rubrik APIs.</p> <pre><code>{\"client_id\":\"client|c9bba9a9-1234-1234-b7c6-123440b4cf64\",\"access_token\":\"eyJ...\",\"expires_in\":43200}\n</code></pre>"},{"location":"authentication/#using-the-access-token","title":"Using the access token","text":"<p>An access token remains valid for 12 hours from the time it is generated. Run the following command to make sure your token is valid:</p> <pre><code>QUERY='{\n  \"query\": \"query {\n      currentUser {\n          email\n          roles {\n              name\n          }\n      }\n  }\"\n}'\n</code></pre> <pre><code>curl -X POST https://$account.my.rubrik-lab.com/api/graphql \\\n--header \"Authorization: Bearer $access_token\" \\\n--header \"Content-type: application/json\" \\\n--data \"$(echo $QUERY)\"\n</code></pre>"},{"location":"authentication/#deleting-a-session","title":"Deleting a session","text":"<p>While there is no restriction on the number of active sessions a service account can have, Rubrik provides an API endpoint to delete an existing session.</p> <p>Run the following command to revoke the session established for the service account:</p> <pre><code>curl -X DELETE https://$account.my.rubrik.com/api/session \\\n--header \"Authorization: Bearer $access_token\" \\\n--header \"Content-type: application/json\"\n</code></pre>"},{"location":"Rubrik-AI/getting-started/","title":"Getting started","text":""},{"location":"Rubrik-AI/getting-started/#what-is-rubrik-ai","title":"What is Rubrik AI?","text":"<p>Rubrik AI unlocks the true potential of your protected data. The data protected by Rubrik becomes a library of business intelligence, and integration with a ChatBot means it will be the smartest employee in the organization.</p>"},{"location":"Rubrik-AI/getting-started/#how-it-works","title":"How it works...","text":"<p>Rubrik AI provides Retrieval-Augmented Generation(RAG) to a Large Language Model(LLM) like OpenAI's GPT-4. This give the ability to create a private chatbot that can answer questions using data from objects protected by Rubrik.</p>"},{"location":"Rubrik-AI/getting-started/#what-about-personally-identifiable-informationpii-in-my-data","title":"What about Personally Identifiable Information(PII) in my data?","text":"<p>Rubrik Data Security Posture Management (DSPM) eliminates potential leakage or unauthorized access of PII described by pre-built and custom policies. This makes Rubrik AI an extremely unique and secure AI solution for data access.</p>"},{"location":"Rubrik-AI/getting-started/#how-do-i-interact-with-rubrik-ai","title":"How do I interact with Rubrik AI?","text":"<ol> <li>Create a <code>retriever</code> in Rubrik Security Cloud. The retriever defines:<ul> <li>The data it can use</li> <li>The sensitive data policy</li> <li>The user role required to use the retriever</li> </ul> </li> <li>Implement and an AI Orchestration Framework<ul> <li>This is responsible for querying the <code>retriever</code> and passing the results to the LLM for an intelligent response.</li> <li>examples include <code>LangChain</code>,<code>Haystack</code>, and <code>llamaindex</code></li> </ul> </li> <li>Deploy a bot<ul> <li>The bot is essentially an API front-end to the orchestration. This allows chat apps like <code>Slack</code> and <code>Microsoft Teams</code>, or even custom web front ends to provide an interface to the user.</li> </ul> </li> </ol>"},{"location":"Rubrik-AI/langchain-example/","title":"Langchain example","text":""},{"location":"Rubrik-AI/langchain-example/#slackbot","title":"Slackbot","text":""},{"location":"Rubrik-AI/langchain-example/#python-environment-setup","title":"Python environment setup","text":""},{"location":"Rubrik-AI/langchain-example/#create-a-retriever","title":"Create a retriever","text":""},{"location":"Rubrik-AI/langchain-example/#rsc-api-authentication","title":"RSC API Authentication","text":""},{"location":"Rubrik-AI/langchain-example/#langchain-configuration","title":"LangChain configuration","text":""},{"location":"Rubrik-AI/langchain-example/#bot-example","title":"Bot example","text":""},{"location":"Rubrik-AI/langchain-example/#_1","title":"...","text":""},{"location":"data-protection/data-center/vmware-vsphere/general-information/","title":"General information","text":"<p>For information on protection capabilities, see the Rubrik Security Cloud documentation</p>"},{"location":"data-protection/data-center/vmware-vsphere/job-status/","title":"Job status","text":""},{"location":"data-protection/data-center/vmware-vsphere/job-status/#description","title":"Description","text":"<p>Monitoring job status may be necessary to continue on after a job is complete.</p> <p>To monitor job status for VMware vSphere, you will need the ID of the cluster where the job is running, and the ID of the request. You can query the task status periodically until a terminal state (<code>SUCCEEDED</code>, <code>FAILED</code>, <code>CANCELLED</code>) is set given in the status field.</p>"},{"location":"data-protection/data-center/vmware-vsphere/job-status/#code-samples","title":"Code Samples","text":""},{"location":"data-protection/data-center/vmware-vsphere/job-status/#graphql","title":"GraphQL","text":"<p><pre><code>query requestStatus($id: String! $clusterUuid: UUID!) {\n  vSphereVMAsyncRequestStatus(id: $id, clusterUuid: $clusterUuid) {\n    id\n    status\n    startTime\n    progress\n    endTime\n    error {\n      message\n    }\n  }\n}\n</code></pre> For complete query capabilities, see the API Reference</p>"},{"location":"data-protection/data-center/vmware-vsphere/job-status/#rubrik-security-cloud-powershell-sdk","title":"Rubrik Security Cloud PowerShell SDK","text":"<pre><code>$statusQuery = New-RscQuery -GqlQuery vSphereVMAsyncRequestStatus\n$statusQuery.var.id = $request.Id\n$statusQuery.var.clusterUuid = $my_vm.cluster.Id\n$status = Invoke-Rsc $statusQuery\n</code></pre>"},{"location":"data-protection/data-center/vmware-vsphere/job-status/#curl","title":"curl","text":"<pre><code>curl --location 'https://EXAMPLE.my.rubrik.com/api/graphql' \\\n--header 'Content-Type: application/json' \\\n--header 'Authorization: Bearer XXXXXXX' \\\n--data '{\"query\":\"query requestStatus($id: String! $clusterUuid: UUID!) {  vSphereVMAsyncRequestStatus(id: $id clusterUuid: $clusterUuid) { id status startTime progress endTime error { message }}}\",\"variables\":{\"id\":\"TASK_ID\",\"clusterUuid\":\"CLUSTER_UUID\"}}'\n</code></pre>"},{"location":"data-protection/data-center/vmware-vsphere/on-demand-backup/","title":"On demand backup","text":""},{"location":"data-protection/data-center/vmware-vsphere/on-demand-backup/#on-demand-backup","title":"On-Demand Backup","text":""},{"location":"data-protection/data-center/vmware-vsphere/virtual-machines/","title":"Virtual machines","text":""},{"location":"data-protection/data-center/vmware-vsphere/virtual-machines/#virtual-machines","title":"Virtual Machines","text":""},{"location":"data-protection/data-center/vmware-vsphere/virtual-machines/#retrieving-virtual-machine-information","title":"Retrieving Virtual Machine Information","text":"<p>To list virtual machines known by Rubrik, you can perform the following. There are various filters to search by name, MOID, cluster, organization, and more.</p> <p>GraphQL API REFERENCE <pre><code>query getVirtualMachines {\n  vSphereVmNewConnection{\n    nodes {\n      name\n      id\n    }\n  }\n}\n</code></pre></p> <p>Rubrik Security Cloud PowerShell SDK</p> <pre><code>Get-RscVmwareVm\n</code></pre> <p>cUrl <pre><code>curl --location 'https://rubrik-gaia.my.rubrik.com/api/graphql' \\\n--header 'Content-Type: application/json' \\\n--header 'Authorization: Bearer XXXXXXX' \\\n--data '{\"query\":\"query getVirtualMachines { vSphereVmNewConnection{nodes { name id }}}\",\"variables\":{}}'\n</code></pre></p>"},{"location":"data-protection/sla-domains/listing/","title":"Listing","text":""},{"location":"data-protection/sla-domains/listing/#getting-all-slas","title":"Getting All SLAs","text":"<pre><code>query {\n  slaDomains {\n    nodes {\n      name\n      id\n      ... on GlobalSlaReply {\n        description\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"data-protection/sla-domains/listing/#getting-an-sla-by-name","title":"Getting an SLA by Name","text":"<p>Generally, the name of the SLA may be known, but not the ID. The <code>slaDomains</code> query allows filtering on several fields, including <code>NAME</code>. <pre><code>query {\n  slaDomains(filter: {field: NAME, text: \"bronze\"}) {\n    nodes {\n      name\n      id\n      ... on GlobalSlaReply {\n        description\n      }\n    }\n  }\n}\n</code></pre></p> <p>Note</p> <p>Name filtering in <code>slaDomains</code> is partial matching. If you provide the name \"bronze\", it will also return any other SLA domain with that name (e.g. \"super-bronze\").</p> <p><code>slaDomains</code> API reference</p>"},{"location":"data-protection/sla-domains/listing/#getting-an-individual-sla","title":"Getting an Individual SLA","text":"<pre><code>query { \n  slaDomain(id: \"2D099E0F-EC23-4A76-BC22-31F69E3EFB67\") {\n    name\n    id\n    ... on GlobalSlaReply {\n        description\n      }\n  }\n}\n</code></pre> <p><code>slaDomain</code> API reference</p>"}]}